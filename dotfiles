#!/bin/bash
# SPDX-License-Identifier: MIT

set -ue

ME=$(basename $0)
HERE=$(readlink -f $(dirname $0))
STDOUT="$(mktemp /tmp/${ME}XXXXX.stdout)"
STDERR="$(mktemp /tmp/${ME}XXXXX.stderr)"

FILES=(
  'HOME/.bashrc.d'
  'HOME/.config/enchant/en_US.dic'
)

red=1
green=2
blue=4

trap "rm -f ${STDOUT} ${STDERR}" ABRT EXIT HUP INT QUIT

function qecho() {
  local N
  local C

  if [[ -z "${QUITE:-}" ]]; then
    [[ "$1" == "-n" ]] && { shift; N="-n"; } || N=""
    C=${1:-7}; shift
    echo ${N:-} -e "\e[3${C}m$*\e[0m"
  fi
}

function vecho() (
  QUITE=""
  qecho "$@"
)

function qcat() {
  if [[ -z "${QUITE:-}" ]]; then
    cat "$1"
  fi
}

function error() {
  vecho ${red} "${ME}:" "$1" >&2
  exit ${2:-1}
}

function runcmd() {
  local E=0

  if [[ "${DRYRUN:-}" ]]; then
    vecho ${blue} "[dry run] $1"
  else
    qecho -n ${blue} "Running $1"
    eval "$1" 1> ${STDOUT} 2> ${STDERR} || E=$?
    if [[ ${E} -eq 0 ]]; then
      qecho ${green} "  [ok]"
      qcat ${STDOUT}
    else
      qecho ${red} "  [error]"
      qcat ${STDERR} >&2
    fi
  fi
  return ${E}
}

function destpath() {
  case "$1" in
    HOME/*)
      echo "${HOME}/${1#*/}"
    ;;
    *)
      echo "$1"
    ;;
  esac
}

function show_file_action() {
  echo "  ${HERE}/$1 <-> $(destpath $1)"
}

function ensure_directory() {
  if [[ ! -d "$1" ]]; then
    runcmd "mkdir -v -p '$1'"
  fi
}

function file_backup() {
  local D="${HERE}/$(dirname $1)"
  local P="$(destpath $1)"

  if [[ -e "${P}" ]]; then
    ensure_directory "${D}"
    runcmd "cp -rv '${P}' '${D}'"
  else
    qecho ${blue} "File or directory '${P}' does not exist, skipping."
  fi
}

function backup_old() {
  local R=5
  local B

  while [[ ${R} -gt 0 ]]; do
    B="$(mktemp -u XXXXX.bak)"
    if [[ ! -e "$1.${B}" ]]; then
      break
    fi
    R=$(( ${R} - 1 ))
  done
  if [[ -e "$1.${B}" ]]; then
    error "backup_old: File '$1.${B}' exits."
  fi
  runcmd "mv -v '$1' '$1.${B}'"
}

function file_restore() {
  local P="${HERE}/$1"
  local D="$(destpath $1)"

  if [[ -e "${P}" ]]; then
    ensure_directory "$(dirname ${D})"
    if [[ "${BACKUP:-}" ]]; then
      backup_old "${D}"
    fi
    runcmd "cp -rv '${P}' '${D}'"
  else
    qecho ${blue} "File or directory '${P}' does not exist, skipping."
  fi
}

function allfiles() {
  local F

  for F in "${FILES[@]}"; do
    $1 "${F}"
  done
}

function usage() {
  cat <<-EOF
	Restore or backup dotfiles.

	Usage: ${ME} OPTIONS {restore,backup}

	where OPTIONS are

	  --backup, -b
	      make backup of old files when restoring; a name of a backup has
	      a form <old file name>.XXXXX.bak, where XXXXX is generated by
	      mktemp -u; a backup is placed in a same directory as its
	      original;

	  --dry-run, -d
	      print what will be done without taking any action;

	  --help, -h, -?
	      print this help and exit;

	  --quite, -q
	      restore/backup files quitely;

	\`${ME} restore\` restores files from script directory,
	\`${ME} backup\` back up files to script directory.

	The list of files that will be restored or backed up is:

	$(allfiles show_file_action)

	EOF
}

function process_options() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --backup|-b)
        BACKUP=y
      ;;
      --dry-run|-d)
        DRYRUN=y
      ;;
      --help|-h|-\?)
        usage
        exit 0
      ;;
      --quite|-q)
        QUITE=y
      ;;
      restore|backup)
        ACTION="$1"
      ;;
      *)
        error "Invalid option/action: '$1'."
      ;;
    esac
    shift
  done || :
}

process_options "$@"

ACTION="${ACTION:-}"
BACKUP="${BACKUP:-}"
DRYRUN="${DRYRUN:-}"
QUITE="${QUITE:-}"

function do_backup() {
  allfiles file_backup
}

function do_restore() {
  allfiles file_restore
}

function perform_action() {
  if [[ "$(type -t do_${ACTION})" == "function" ]]; then
    do_${ACTION}
  else
    error "'${ACTION}' is not action."
  fi
}

perform_action
