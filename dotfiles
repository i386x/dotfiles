#!/bin/bash
# SPDX-License-Identifier: MIT

set -ue

ME=$(basename $0)
HERE=$(readlink -f $(dirname $0))
STDOUT="$(mktemp /tmp/${ME}XXXXX.stdout)"
STDERR="$(mktemp /tmp/${ME}XXXXX.stderr)"

FILES=(
  'HOME/.bashrc.d'
  'HOME/.config/enchant/en_US.dic'
  'HOME/.config/git/.gitmessage'
)

red=1
green=2
blue=4

trap "rm -f ${STDOUT} ${STDERR}" ABRT EXIT HUP INT QUIT

function qecho() {
  local N
  local C

  if [[ -z "${QUITE:-}" ]]; then
    [[ "$1" == "-n" ]] && { shift; N="-n"; } || N=""
    C=${1:-7}; shift
    echo ${N:-} -e "\e[3${C}m$*\e[0m"
  fi
}

function vecho() (
  QUITE=""
  qecho "$@"
)

function qcat() {
  if [[ -z "${QUITE:-}" ]]; then
    cat "$1"
  fi
}

function error() {
  vecho ${red} "${ME}:" "$1" >&2
  exit ${2:-1}
}

function file_lookup() {
  if [[ "${1:-}" =~ ^[0-9]+$ ]]; then
    echo "${FILES[$1]}"
  else
    echo "${1:-}"
  fi
}

function runcmd() {
  local E=0

  if [[ "${DRYRUN:-}" ]]; then
    vecho ${blue} "[dry run] $1"
  else
    qecho -n ${blue} "Running $1"
    eval "$1" 1> ${STDOUT} 2> ${STDERR} || E=$?
    if [[ ${E} -eq 0 ]]; then
      qecho ${green} "  [ok]"
      qcat ${STDOUT}
    else
      qecho ${red} "  [error]"
      qcat ${STDERR} >&2
    fi
  fi
  return ${E}
}

function destpath() {
  case "$1" in
    HOME/*)
      echo "${HOME}/${1#*/}"
    ;;
    *)
      echo "$1"
    ;;
  esac
}

function show_file_action() {
  echo "  $1: ${HERE}/$2 <-> $(destpath $2)"
}

function ensure_directory() {
  if [[ ! -d "$1" ]]; then
    runcmd "mkdir -v -p '$1'"
  fi
}

function file_backup() {
  shift
  local D="${HERE}/$(dirname "$(file_lookup "$1")")"
  local P="$(destpath "$(file_lookup "$1")")"

  if [[ -e "${P}" ]]; then
    ensure_directory "${D}"
    runcmd "cp -rv '${P}' '${D}'"
  else
    qecho ${blue} "File or directory '${P}' does not exist, skipping."
  fi
}

function backup_old() {
  local R=5
  local B

  while [[ ${R} -gt 0 ]]; do
    B="$(mktemp -u XXXXX.bak)"
    if [[ ! -e "$1.${B}" ]]; then
      break
    fi
    R=$(( R - 1 ))
  done
  if [[ -e "$1.${B}" ]]; then
    error "backup_old: File '$1.${B}' exits."
  fi
  runcmd "mv -v '$1' '$1.${B}'"
}

function file_restore() {
  shift
  local P="${HERE}/$(file_lookup "$1")"
  local D="$(destpath "$(file_lookup "$1")")"

  if [[ -e "${P}" ]]; then
    ensure_directory "$(dirname ${D})"
    if [[ "${BACKUP:-}" ]]; then
      backup_old "${D}"
    fi
    runcmd "cp -rv '${P}' '${D}'"
  else
    qecho ${blue} "File or directory '${P}' does not exist, skipping."
  fi
}

function allfiles() {
  local A
  local F
  local I

  A=$1; shift
  I=0
  for F in "${@:-${FILES[@]}}"; do
    $A ${I} "${F}"
    I=$(( I + 1 ))
  done
}

function usage() {
  cat <<-EOF
	Restore or backup dot files or directories.

	Usage: ${ME} OPTIONS {restore,backup} [FILES]

	where OPTIONS are

	  -b, --backup
	      make a backup of old files or directories when restoring; a name
	      of a backup has a form <old file name>.XXXXX.bak, where XXXXX is
	      generated by \`mktemp -u\`; a backup is placed in the same
	      directory as its original;

	  -d, --dry-run
	      print what will be done without taking any action;

	  -h, -?, --help
	      print this help and exit;

	  -q, --quite
	      restore or backup files or directories quitely;

	\`${ME} restore\` restores files or directories from the script
	directory, \`${ME} backup\` backup files or directories to the script
	directory.

	FILES can further specify which files or directories should be restored
	or backed up. A file or directory can be specified both as an index to
	the FILES array (see the list of files below) or a path starting with
	\`HOME\`, which denotes home directory.

	The list of files or directories that will be restored or backed up is:

	$(allfiles show_file_action)

	EOF
}

PROCESSED=0

function process_options() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --backup|-b)
        BACKUP=y
      ;;
      --dry-run|-d)
        DRYRUN=y
      ;;
      --help|-h|-\?)
        usage
        exit 0
      ;;
      --quite|-q)
        QUITE=y
      ;;
      restore|backup)
        ACTION="$1"; shift; PROCESSED=$(( PROCESSED + 1 ))
        break
      ;;
      *)
        error "Invalid option/action: '$1'."
      ;;
    esac
    shift; PROCESSED=$(( PROCESSED + 1 ))
  done || :
}

process_options "$@"
shift ${PROCESSED}

ACTION="${ACTION:-}"
BACKUP="${BACKUP:-}"
DRYRUN="${DRYRUN:-}"
QUITE="${QUITE:-}"

function do_backup() {
  allfiles file_backup "$@"
}

function do_restore() {
  allfiles file_restore "$@"
}

function perform_action() {
  if [[ "$(type -t do_${ACTION})" == "function" ]]; then
    do_${ACTION} "$@"
  else
    error "'${ACTION}' is not action."
  fi
}

perform_action "$@"
